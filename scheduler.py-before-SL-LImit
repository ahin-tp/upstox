import schedule
import time
import pytz
from datetime import datetime, time as dtime

from db import (
    get_pending_orders,
    get_all_orders,
    save_order_ids,
    mark_cancelled,
    mark_exited
)

from trader import (
    place_entry,
    wait_for_entry_execution,
    place_stop_loss,
    get_order_status,
    has_open_position
)

# ===============================
# CONFIG
# ===============================
TIMEZONE = pytz.timezone("Asia/Kolkata")

ENTRY_TIME = dtime(10, 10, 10)
WINDOW_SECONDS = 30
entry_done_today = False


# ===============================
# ENTRY FLOW
# ===============================
def run_orders():
    now = datetime.now(TIMEZONE).strftime("%H:%M:%S")
    print(f"[{now}] üöÄ Scheduler started (ENTRY FLOW)", flush=True)

    orders = get_pending_orders()

    if not orders:
        print("‚ÑπÔ∏è No pending orders found", flush=True)
        return

    for order in orders:
        try:
            # ‚úÖ SAFE COLUMN ACCESS
            db_id = order["id"]
            instrument = order["instrument"]
            qty = order["qty"]
            trigger = order["trigger"]
            limit_price = order["limit_price"]
            sl = order["stop_loss"]

            print(f"üì• Placing ENTRY for DB ID {db_id}", flush=True)

            # 1Ô∏è‚É£ Place ENTRY
            entry_order_id = place_entry(
                (db_id, instrument, qty, trigger, limit_price, sl)
            )
            print(f"‚úÖ ENTRY placed: {entry_order_id}", flush=True)

            # 2Ô∏è‚É£ Wait for execution
            executed = wait_for_entry_execution(entry_order_id)

            if not executed:
                print(f"‚ùå ENTRY not executed for DB ID {db_id}", flush=True)
                mark_cancelled(db_id)
                continue

            print(f"‚úÖ ENTRY executed for DB ID {db_id}", flush=True)

            # 3Ô∏è‚É£ Place STOP LOSS
            sl_order_id = place_stop_loss(instrument, qty, sl)

            # 4Ô∏è‚É£ Save IDs
            save_order_ids(db_id, entry_order_id, sl_order_id)

            print(
                f"üìå DB:{db_id} ENTRY:{entry_order_id} SL:{sl_order_id}",
                flush=True
            )

        except Exception as e:
            print(f"‚ùå ENTRY FLOW ERROR DB ID {order['id']} ‚Üí {e}", flush=True)


# ===============================
# ENTRY GUARD
# ===============================
def entry_guard():
    global entry_done_today

    now = datetime.now(TIMEZONE)

    # Reset at midnight
    if now.hour == 0 and now.minute == 0:
        entry_done_today = False

    target_time = now.replace(
        hour=ENTRY_TIME.hour,
        minute=ENTRY_TIME.minute,
        second=ENTRY_TIME.second,
        microsecond=0
    )

    diff_seconds = abs((now - target_time).total_seconds())

    if diff_seconds <= WINDOW_SECONDS and not entry_done_today:
        print("üöÄ ENTRY WINDOW HIT", flush=True)
        run_orders()
        entry_done_today = True


# ===============================
# RECONCILIATION
# ===============================
def reconcile_with_upstox():
    now = datetime.now(TIMEZONE).strftime("%H:%M:%S")
    print(f"[{now}] üîÑ Reconciliation started", flush=True)

    orders = get_all_orders()

    for o in orders:
        try:
            # ‚úÖ SAFE COLUMN ACCESS
            db_id = o["id"]
            instrument = o["instrument"]
            entry_order_id = o["entry_order_id"]
            status = o["status"]

            if status == "PENDING" and entry_order_id:
                broker_status = get_order_status(entry_order_id)
                if broker_status in ("CANCELLED", "REJECTED"):
                    print(f"‚ùå DB:{db_id} cancelled in Upstox", flush=True)
                    mark_cancelled(db_id)

            if status == "EXECUTED":
                if not has_open_position(instrument):
                    print(f"üèÅ DB:{db_id} exited in Upstox", flush=True)
                    mark_exited(db_id)

        except Exception as e:
            print(f"‚ùå RECON ERROR DB ID {o['id']} ‚Üí {e}", flush=True)


# ===============================
# SCHEDULER SETUP
# ===============================
schedule.every(5).seconds.do(entry_guard)
schedule.every(1).minutes.do(reconcile_with_upstox)

print("‚è≥ Scheduler running (ENTRY + RECONCILIATION)...", flush=True)

while True:
    schedule.run_pending()
    time.sleep(1)
