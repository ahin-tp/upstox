import schedule
import time
import pytz
from datetime import datetime, time as dtime
#from datetime import timedelta

from db import (
    get_pending_orders,
    get_all_orders,
    save_order_ids,
    mark_cancelled,
    mark_exited
)

from trader import (
    place_entry,
    wait_for_entry_execution,
    place_stop_loss,
    get_order_status,
    has_open_position
)

# ===============================
# CONFIG
# ===============================
TIMEZONE = pytz.timezone("Asia/Kolkata")

#ENTRY_TIME = dtime(11, 30)      # üî• TEST TIME ‚Üí 11:30 AM IST
#ENTRY_TIME = (datetime.now(TIMEZONE) + timedelta(minutes=1)).time()
ENTRY_TIME = dtime(9, 15, 10)
WINDOW_SECONDS = 30            # 2-minute execution window
entry_done_today = False        # prevents duplicate entries


# ===============================
# ENTRY FLOW
# ===============================
def run_orders():
    now = datetime.now(TIMEZONE).strftime("%H:%M:%S")
    print(f"[{now}] üöÄ Scheduler started (ENTRY FLOW)")

    orders = get_pending_orders()

    if not orders:
        print("‚ÑπÔ∏è No pending orders found")
        return

    for order in orders:
        try:
            db_id, instrument, qty, trigger, limit_price, sl = order

            print(f"üì• Placing ENTRY for DB ID {db_id}")

            # 1Ô∏è‚É£ Place ENTRY
            entry_order_id = place_entry(order)
            print(f"‚úÖ ENTRY placed: {entry_order_id}")

            # 2Ô∏è‚É£ Wait for execution
            executed = wait_for_entry_execution(entry_order_id)

            if not executed:
                print(f"‚ùå ENTRY not executed for DB ID {db_id}")
                mark_cancelled(db_id)
                continue

            print(f"‚úÖ ENTRY executed for DB ID {db_id}")

            # 3Ô∏è‚É£ Place STOP LOSS
            sl_order_id = place_stop_loss(instrument, qty, sl)

            # 4Ô∏è‚É£ Save order IDs
            save_order_ids(db_id, entry_order_id, sl_order_id)

            print(f"üìå DB:{db_id} ENTRY:{entry_order_id} SL:{sl_order_id}")

        except Exception as e:
            print(f"‚ùå ENTRY FLOW ERROR DB ID {order[0]} ‚Üí {e}")


# ===============================
# ENTRY GUARD (TIME WINDOW)
# ===============================
def entry_guard():
    global entry_done_today

    now = datetime.now(TIMEZONE)

    # Reset flag at midnight
    if now.hour == 0 and now.minute == 0:
        entry_done_today = False

    target_time = now.replace(
        hour=ENTRY_TIME.hour,
        minute=ENTRY_TIME.minute,
#       second=0,
        second=ENTRY_TIME.second,
        microsecond=0
    )

    diff_seconds = abs((now - target_time).total_seconds())

    if diff_seconds <= WINDOW_SECONDS and not entry_done_today:
        print("üöÄ ENTRY WINDOW HIT")
        run_orders()
        entry_done_today = True


# ===============================
# RECONCILIATION JOB
# ===============================
def reconcile_with_upstox():
    now = datetime.now(TIMEZONE).strftime("%H:%M:%S")
    print(f"[{now}] üîÑ Reconciliation started")

    orders = get_all_orders()

    for o in orders:
        (
            db_id,
            instrument,
            qty,
            trigger,
            limit_price,
            sl,
            entry_order_id,
            sl_order_id,
            status
        ) = o

        try:
            # ----------------------------
            # PENDING ‚Üí CANCELLED
            # ----------------------------
            if status == "PENDING" and entry_order_id:
                broker_status = get_order_status(entry_order_id)

                if broker_status in ("CANCELLED", "REJECTED"):
                    print(f"‚ùå DB:{db_id} cancelled in Upstox")
                    mark_cancelled(db_id)

            # ----------------------------
            # EXECUTED ‚Üí EXITED
            # ----------------------------
            if status == "EXECUTED":
                open_pos = has_open_position(instrument)

                if not open_pos:
                    print(f"üèÅ DB:{db_id} exited in Upstox")
                    mark_exited(db_id)

        except Exception as e:
            print(f"‚ùå RECON ERROR DB ID {db_id} ‚Üí {e}")


# ===============================
# SCHEDULER SETUP
# ===============================
schedule.every(5).seconds.do(entry_guard)        # ‚è∞ Entry window checker
schedule.every(1).minutes.do(reconcile_with_upstox)

print("‚è≥ Scheduler running (ENTRY + RECONCILIATION)...")

while True:
    schedule.run_pending()
    time.sleep(1)
