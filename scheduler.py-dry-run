import schedule
import time
import pytz
from datetime import datetime, time as dtime, timedelta

from db import (
    get_pending_orders,
    get_all_orders,
    save_order_ids,
    mark_cancelled,
    mark_exited
)

from trader import (
    place_entry,
    wait_for_entry_execution,
    place_stop_loss,
    get_order_status,
    has_open_position
)

# ===============================
# CONFIG
# ===============================
TIMEZONE = pytz.timezone("Asia/Kolkata")

DRY_RUN = True   # üî• IMPORTANT: Dry run mode

# üîÅ Trigger in 1 minute from now (for testing)
ENTRY_TIME = (datetime.now(TIMEZONE) + timedelta(minutes=1)).time()

WINDOW_SECONDS = 30
entry_done_today = False


# ===============================
# ENTRY FLOW
# ===============================
def run_orders():
    now = datetime.now(TIMEZONE).strftime("%H:%M:%S")
    print(f"[{now}] üöÄ Scheduler started (ENTRY FLOW)", flush=True)

    orders = get_pending_orders()

    if not orders:
        print("‚ÑπÔ∏è No pending orders found", flush=True)
        return

    for order in orders:
        db_id, instrument, qty, trigger, limit_price, sl = order

        print(f"üì• DRY RUN ‚Üí Would place ENTRY for DB ID {db_id}", flush=True)
        print(
            f"    Instrument={instrument}, Qty={qty}, Trigger={trigger}, Limit={limit_price}, SL={sl}",
            flush=True
        )

        if DRY_RUN:
            print(f"üß™ DRY RUN ‚Üí Skipping real order placement for DB ID {db_id}", flush=True)
            continue   # üî• DO NOT touch Upstox or DB

        # ---- REAL FLOW (disabled in dry run) ----
        entry_order_id = place_entry(order)
        executed = wait_for_entry_execution(entry_order_id)

        if not executed:
            mark_cancelled(db_id)
            continue

        sl_order_id = place_stop_loss(instrument, qty, sl)
        save_order_ids(db_id, entry_order_id, sl_order_id)


# ===============================
# ENTRY GUARD
# ===============================
def entry_guard():
    global entry_done_today

    now = datetime.now(TIMEZONE)

    target_time = now.replace(
        hour=ENTRY_TIME.hour,
        minute=ENTRY_TIME.minute,
        second=ENTRY_TIME.second,
        microsecond=0
    )

    diff_seconds = abs((now - target_time).total_seconds())

    if diff_seconds <= WINDOW_SECONDS and not entry_done_today:
        print("üöÄ ENTRY WINDOW HIT", flush=True)
        run_orders()
        entry_done_today = True


# ===============================
# RECONCILIATION (UNCHANGED)
# ===============================
def reconcile_with_upstox():
    now = datetime.now(TIMEZONE).strftime("%H:%M:%S")
    print(f"[{now}] üîÑ Reconciliation started", flush=True)

    orders = get_all_orders()

    for o in orders:
        (
            db_id,
            instrument,
            qty,
            trigger,
            limit_price,
            sl,
            entry_order_id,
            sl_order_id,
            status
        ) = o

        try:
            if status == "PENDING" and entry_order_id:
                broker_status = get_order_status(entry_order_id)
                if broker_status in ("CANCELLED", "REJECTED"):
                    mark_cancelled(db_id)

            if status == "EXECUTED":
                if not has_open_position(instrument):
                    mark_exited(db_id)

        except Exception as e:
            print(f"‚ùå RECON ERROR DB ID {db_id} ‚Üí {e}", flush=True)


# ===============================
# SCHEDULER SETUP
# ===============================
schedule.every(5).seconds.do(entry_guard)
schedule.every(1).minutes.do(reconcile_with_upstox)

print("‚è≥ Scheduler running (ENTRY + RECONCILIATION) [DRY RUN MODE]", flush=True)

while True:
    schedule.run_pending()
    time.sleep(1)
